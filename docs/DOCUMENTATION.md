# Documentation

## Reference on function indentification syntax

Every character before the `(` denotes what is modified, which can be any of the following:

- `d`: Modifies the data
- `i`: Modifies the input string (Read only)
- `c`: Modifies the control flow (AKA the interpreter state)
- `e`: Modifies the executed string (Read only)

If you see a syntax like `c1->c2`, then it means that it reads from c1 and writes to c2, for example, e->d means that it reads from the executed string and writes to the data

If you see a syntax like `c1,c2`, then it means that everything until the `,` on the `(...)` part is taken from c1, and the rest is taken from c2

Both syntaxes can be combined, for example, `c1,c2->c3,c4,c5`

Everything inside the parentheses is the stuff pushed, readed and popped from the previous things

Everything before `--` is what is popped/readed

If there is a `->` instead of a `--`, then it means that it takes the entire data, like on `!`

The parameters are separated by a space

If a parameter has a `:` before its name, then it is just readed from the data without popping

This is an example for a user defined instruction (denoted by the `$`) called `$s`
```east
# ($s) d( x -- x2 ) Square the given x
```

A bigger example showing everything explained here:

```east
# ($e) d,i,e->c,d( top :readed, input, c1 -- skip, pushed_item ) A complex function that explains everything here
```

And now, for the actual documentation:

## Instruction `>`
**i( -- )**

Go to the next character on the input string

## Instruction `<`
**i( -- )**

Go to the previous character in the input string

## Instruction `.`
**i->d( in -- char )**

Push the current input character to the data

## Instruction `,`
**d( top -- )**

Pop the topmost item from the data

## Instruction `&`
**d( top -- copy copy )**

Duplicate the topmost item from the data

## Instruction `;`
**d->i( top -- char )**

Pop and print the topmost character from the data

## Instruction `:`
**d->i( top -- number )**

Pop and print the topmost character from the data as a number

## Instruction `+`
**d( item1 item2 -- result )**

Add the two topmost items of the data

## Instruction `-`
**d( item1 item2 -- result )**

Substract the two topmost items of the data

## Instruction `*`
**d( item1 item2 -- result )**

Multiply the two topmost items of the data

## Instruction `/`
**d( item1 item2 -- result )**

Divide the two topmost items of the data, if the top one is 0, then it gets replaced with 1 to prevent "division by zero" errors

## Instruction `!`
**d( everything -> reversed )**

Reverse the entire data, for example, 'a' 'b' 'c' -> 'c' 'b' 'a'

## Instruction `@`
**d( bottom -> top )**

Rotate the stack once (AKA put the last item first, 'a' 'b' 'c' -> 'b' 'c' 'a')

## Instruction `=`
**d( until_NUL -- execute_result )**

Read (not pop) everything until a NUL, reverse it, and execute it as East code, only being able to modify the data (the rest is isolated)

## Instruction `\`
**e->d( char -- escaped_item )**

Push the following character escaped, based on the hardcoded "escaped" array

## Instruction `[`
**c( -- waypoint )**

Set the waypoint used in `]`, which checks the input character

## Instruction `]`
**c,i( waypoint,current -- )**

Return (set pc) to the last input waypoint if the current character on the input string is not NUL

## Instruction `{`
**c( -- waypoint )**

Set the waypoint used in `}`, which checks the topmost item of the data

## Instruction `}`
**c,d( waypoint,top -- )**

Return (set pc) to the last data waypoint if the topmost item of the stack isn't NUL (or if the stack isn't empty)

## Instruction `?`
**d,c( top :2nd -- skip1 )**

If the top two items on the data are equal, the next instruction is skipped, otherwise, it is executed. The last element of the data is always popped

## Instruction `#`
**e( skip -> )**

Ignores everything until a newline or a NUL is found on the executed string

## Instruction `%`
**c( until_end -> )**

Declare a user defined instruction, for later access with `$`, the function declaration is from the % (taking the next character as the name) to the corresponding '^'

## Instruction `$`
**c( user_defined -- user_defined )**

Execute user defined function, the next character is used as the name of it

Generated by EDoc